
int** draftMatrizAlineada(const char* cad1, const char* cad2,
                        int** matriz, int** matriz_puntajes,
                        int gap_score){
    int columna = strlen(cad1)+1;
    int fila = strlen(cad2)+1;

    //se crea una matriz alineacion para luego graficarla en Graphviz.
    //esta funcion es de solo 0s y 1s, los 1 indican el camino, los unicos lugares que tendran el 1 es el camino optimo. 
    int** matriz_alineacion = new int*[fila];
    for (int i = 0; i <= fila; ++i) {
        matriz[i] = new int[columna];
    }


    for (int i = 0; i<=fila; i++){
        for (int j = 0;j<=columna;j++){
            if (i==0 && j==0){
                matriz[i][j] = 0;
            } else if (i>0 && j == 0){
                matriz[i][j] = matriz[i-1][j] + gap_score;

                matriz_alineacion[i][j] = 1;
            } else if (i==0 && j>0){
                matriz[i][j] = matriz[i][j-1] + gap_score;
                matriz_alineacion[i][j] = 1;

            } else if (i>0 && j>0) {
                matriz[i][j] = maximo(
                    matriz[i-1][j]+gap_score,
                    matriz[i][j-1]+gap_score,
                    matriz[i-1][j-1]+valorPuntuacion(matriz_puntajes,cad2[i-1],cad1[j-1])
                    );
                
                
            }
            cout << "Se asigna " << matriz[i][j] << endl;
        } 
    }    
    imprimir_alineamiento(matriz,cad1,cad2);
}



------------------------------------------------------------

en el main se debe hacer un system() para crear el archivo

------------------------------------------------------------


#include <fstream>
#include <vector>
#include <string>
#include <fstream>
#include <vector>
#include <string>

// Función para generar el archivo .dot del traceback
void generate_traceback_graph(int** matriz_puntuacion, int** matriz_alineacion, const string archivo) {
    std::ofstream file(archivo);
    if (!file) {
        std::cout "No se pudo abrir el archivo"
    }

    file << "digraph Traceback {\n";
    file << "    node [shape=box, style=filled];\n";

    size_t fila = matriz_puntuacion.size();
    size_t columna = matriz_puntuacion[0].size();

    string color;
    // Crear nodos y asignar color según sea parte del camino óptimo
    for (size_t i = 0; i < fila; ++i) {
        for (size_t j = 0; j < columna; ++j) {
            if(matriz_alineacion[i][j] == 1){
                color = "lightgreen";
            } else {
                color = "lightgray";
            };
            file << "    n" << i << "_" << j << " [label=\"" << matriz_puntuacion[i][j] 
                 << "\", fillcolor=\"" << color << "\"];\n";
        }
    }

    // Crear aristas
    for (size_t i = 0; i < fila; ++i) {
        for (size_t j = 0; j < columna; ++j) {
            if (traceback[i][j] == 1) {
                // Conectar al nodo diagonal, superior, o izquierdo si están en el camino óptimo
                if (i > 0 && j > 0 && matriz_alineacion[i - 1][j - 1] == 1) {
                    file << "    n" << i << "_" << j << " -> n" << (i - 1) << "_" << (j - 1) << ";\n";
                }
                if (i > 0 && matriz_alineacion[i - 1][j] == 1) {
                    file << "    n" << i << "_" << j << " -> n" << (i - 1) << "_" << j << ";\n";
                }
                if (j > 0 && matriz_alineacion[i][j - 1] == 1) {
                    file << "    n" << i << "_" << j << " -> n" << i << "_" << (j - 1) << ";\n";
                }
            }
        }
    }

    file << "}\n";
    file.close();
    system(comando para que el .dot pase a .png)

}

